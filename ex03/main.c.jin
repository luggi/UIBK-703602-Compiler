/* Authors:
 * - Huber Lukas
 * - Alexander Hirsch
 * - Patrick Ober
 * - Michael Tscholl
 * - Franz Josef Haider
 */

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#include "lexer.h"
#include "tokens.h"

static struct token current;

/* compares `expect` with next token, calls `exit()` on missmatch */
void match(const enum token_type expect) {
    printf("Debug: testing %20s\n", current.text);

    /* test current token */
    if (current.type != expect) {
        fprintf(stderr, "Error: Line %d: read '%s', expected '%s'\n",
                current.line, token_type_string(current.type),
                token_type_string(expect));
        lexer_destroy();
        exit(EXIT_FAILURE);
    }

    /* move on */
    current = lexer_next();
}

/* print error message and exit */
void no_match() {
    fprintf(stderr, "Error: Line %d: unexpected token '%s'\n", current.line,
            token_type_string(current.type));
    lexer_destroy();
    exit(EXIT_FAILURE);
}

/* rules */
{%- for name in RULES %}
void {{name}}(void);
{%- endfor %}
{% for name, options in RULES.iteritems() %}
void {{name}}(void) {
    puts("Debug: enter {{name}}");
    printf("Debug: testing %20s\n", current.text);
    switch(current.type) {
        {%- for line in options if line != [] %}
            {%- for word in line %}
                {%- if loop.first %}
        case {{word}}:
                current = lexer_next();
                {%- else %}
                    {%- if word in TOKENS %}
            match({{word}});
                    {%- else %}
            {{word}}();
                    {%- endif %}
                {%- endif %}
            {%- endfor %}
            break;
        {% endfor %}

        {%- if [] in options %}
        default:
            break;
        {%- else %}
        default:
            puts("Debug: rejecting {{name}}");
            no_match();
            return;
        {%- endif %}
    }
    puts("Debug: accept {{name}}");
}
{% endfor %}

int main(int argc, char *argv[]) {
    lexer_create();

    /* read in first token */
    current = lexer_next();

    /* run parser, calls exit on failure */
    start();

    puts("input looks ok");

    lexer_destroy();

    return EXIT_SUCCESS;
}
